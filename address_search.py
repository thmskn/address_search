# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Address_search
                                 A QGIS plugin
 Zum suchen einer Adresse
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-11-28
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Thomas Kn√§uper
        email                : thomas.knaeuper@stud.hs-bochum.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import * #QSettings, QTranslator, QCoreApplication, Qt, QAbstractTableModel
from qgis.PyQt.QtGui import * #QIcon
from qgis.PyQt.QtSql import *
from qgis.PyQt.QtWidgets import *
#(QAction, QApplication, QDockWidget,QHeaderView,QMenu,QMessageBox,QTableWidgetItem,QTableView,QToolButton)

# Initialize Qt resources from file resources.py
from .resources import *
#from PyQt5.QtWidgets import QAction, QMessageBox
import sys

import pandas as pd
import sqlite3

# Import the code for the DockWidget
from .address_search_dockwidget import Address_searchDockWidget
import os.path


class Address_search:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
                # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Address_search_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Adresssuche')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'Address_search')
        self.toolbar.setObjectName(u'Address_search')

        #print "** INITIALIZING Address_search"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Address_search', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/address_search/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Adresssuche'),
            callback=self.run,
            parent=self.iface.mainWindow())

        if self.dockwidget is None:
            self.dockwidget=Address_searchDockWidget()

        self.dockwidget.btn_Test.clicked.connect(self.txtToCsv)

        #print('Test!')

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING Address_search"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD Address_search"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Adresssuche'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def loadWFS(self):

        #self.dockwidget=Address_searchDockWidget()
        self.dockwidget.label_Test.setText('Test!!!')
        QMessageBox.information(None, 'Addresssuche', 'Dies ist ein Test!')
        base_url = 'C:/Users/thoma/AppData/Roaming/QGIS/QGIS3/profiles/default/python/plugins/Georeferenzierte_Hausnummer_01_10_2022.txt'
        self.iface.addVectorLayer(base_url, "Hauskoordinaten", "Hauskoords KrHf")

    #--------------------------------------------------------------------------

    def txtToCsv(self):

        data = pd.read_csv ('C:/Users/thoma/AppData/Roaming/QGIS/QGIS3/profiles/default/python/plugins/GeoHnr_Kopie.csv',delimiter=';', header=0)
        print(data)
        print('Columns: ' + data.columns)
        data.pop('NBA')
        data1 = data[['HNR','ADZ','RW','NW','STN','PLZ','ONM','ZON','POT']]
        print('Without:')
        print(data1)

        con = sqlite3.connect("C:/Users/thoma/AppData/Roaming/QGIS/QGIS3/profiles/default/python/plugins/Adressen.db")
        cur = con.cursor()
        cur.execute("CREATE TABLE IF NOT EXISTS adressen(HNR, ADZ, RW, NW, STN, PLZ, ONM, ZON, POT)")
        
        data1.to_sql('adressen', con, if_exists='replace', index=True)

    
        cur.execute("SELECT * FROM adressen")
        print(cur.fetchall())

        cur.execute("SELECT STN FROM adressen")
        strassen = []

        for row in cur:
            for field in row:
                strassen.append(field)
        print(strassen)

        #self.dockwidget.cmb_Liste.addItems(strassen)


        geek_list = [["Sayian", "Super Saiyan"], ["Super Sayian 2", 
                                               "Super Sayian B"]]
  
        # making it editable
        #self.combo_box.setEditable(True)

        # self.model = QSqlTableModel(self)
        # self.model.setTable("Departments")
        # self.model.select()

        # self.tableview = QTableView()
        # self.tableview.setModel(self.model)

        # self.combo = QComboBox()
        # self.combo.setModel(self.model)
        # column = self.model.record().indexOf("department")
        # self.combo.setModelColumn(column)

        # #self.combo.currentIndexChanged.connect(self.onCurrentIndexChanged)

        # lay = QtWidgets.QVBoxLayout(self)
        # lay.addWidget(self.tableview)
        # lay.addWidget(self.combo)


        # d = (
        #     (1, "department1"),
        #     (2, "department2"),
        #     (3, "department3"),
        #     (4, "department4"),
        #     (5, "department5"),
        # )

        # self.dockwidget = QStandardItemModel(self)

        # for id_, value in d:
        #     it = QStandardItem(value)
        #     it.setData(id_, IdRole)
        #     self.model.appendRow(it)

        # self.dockwidget.cmb_Liste = QtWidgets.QComboBox()
        # self.dockwidget.cmb_Liste.setModel(self.model)

        # lay = QtWidgets.QVBoxLayout(self)
        # lay.addWidget(self.dockwidget.cmb_Liste)


  
        view = QTableView()
  
        # setting view to combo box
        self.dockwidget.cmb_Liste.setView(view)

        # Table Model
        #self.model = TableModel(data)
        #self.table.setModel(self.model)

        # adding list of items to combo box
        self.dockwidget.cmb_Liste.addItems(geek_list)



        # with open('data.csv','r') as fin: # `with` statement available in 2.5+
        #     # csv.DictReader uses first line in file for column headings by default
        #      # comma is default delimiter
        #     to_db = [(i['col1'], i['col2']) for i in data]

        # cur.executemany("INSERT INTO t (col1, col2) VALUES (?, ?);", to_db)
        # con.commit()
        con.close()
        
        #QMessageBox.information(None, 'Addresssuche', 'Success!')
        
    def run(self):
        """Run method that loads and starts the plugin"""
        print ('Hello')
        #self.label_Test.setText('Hello!')

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING Address_search"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = Address_searchDockWidget()


            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)
            #QMessageBox.information(None, 'Minimal plugin', 'Do something useless here')

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
